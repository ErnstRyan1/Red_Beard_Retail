#perl
#ver 1.51
#author : Seneca Menard
#This script is for exporting terrain with TWO uv maps out to a new model while applying the terrain material and deleting the source uv map.

#INSTRUCTIONS :
	#1 : You should have two uv maps.  One for the "source mesh" and one for the "continuous mesh".
		#1a : The "continuous mesh" uv map name must have the same name as the continous material name.  Here's an example for the crazyJoel map : "terrain/wasteland1/crazyJoel/cj_terrain"
		#1b : The "original tiling textures" uv map can have any name.
	#2 : This script can either export the entire layer to one continous model, or you can have it cut out specially flagged polys from that layer and have it save that out to an additional file.
		#2a : If you only want to the entire layer to one continous model, you don't need to do anything special.
		#2b : If you want it to cut the special polys from this layer and save that out to a new file (like for spires and pillars that aren't merged into the continuous model), you must apply a selection set to those special polys called "nonUnique".

#FILE NAME NOTES :
	#Don't forget that the layer you're running this script on should have "_src" in the name so that the freezeModel2.pl script will save out the proper name.
	#So if your scene name is called "nh.lxo" and your layer name is called "terrain_src", these are the three files that will be generated by freezeModel2.pl and this script :
		#1 : nh_terrain_src.lwo			(by freezeModel2.pl)
		#2 : nh_terrain.lwo				(by freezeModel_exportTerrain.pl)
		#3 : nh_terrain_models.lwo		(by freezeModel_exportTerrain.pl)

#IMPORTANT NOTE : This script only saves out the (tiling texture terrain) and the (separete pieces, ie floating rocks).  It DOESN'T save the original LXO and it DOESN'T save the full current layer out to the _src model.  @freezemodel2.pl does those two, so you need to use both scripts.


#(8-13-08 fix) : noticed a small bug with vertex map choices and layer indices.
#(9-29-10 fix) : script now knows to delete mesh instances and static meshes as well. (which also fixes a vmap query bug)
#(11-2-10 fix) : fixed a syntax change for 501


#setup
my $modoVer = lxq("query platformservice appversion ?");
if ($modoVer > 500){our $lwoType = "\$NLWO2";} else {our $lwoType = "\$LWO2";}
my $mainlayer = lxq("query layerservice layers ? main");
my $mainlayerID = lxq("query layerservice layer.id ? $mainlayer");
my $mainlayerName = lxq("query layerservice layer.name ? $mainlayer");
if ($mainlayerName !~ /_src/i){die("The main layer name does not have '_src' at the end of it and so I'm cancelling the script");}
if (lxq("layer.setVisibility {$mainlayerID} ?") == 0){lx("layer.setVisibility {$mainlayerID} 1");}
my $bakeUVmapName ="";

my $sceneName = lxq("query sceneservice scene.file ? current");
$sceneName =~ s/\.l[wx]o//i;
$mainlayerName =~ s/_src//i;
$sceneName = $sceneName . "_" . $mainlayerName . "\.lwo";


#first, save the original scene
if (-e $sceneName){
	unless (-w $sceneName){
		popup("The frozen model IS write protected and so I'm cancelling the script");
		die;
	}
}
#lx("!!scene.save");  #why save the scene again when freezemodel2 is going to save it..?


#delete all other layers
my $layerCount = lxq("query layerservice layer.n ? all");
lx("!!select.drop item");
my $deleteCount;
for (my $i=1; $i<$layerCount+1; $i++){
	if ($i != $mainlayer){
		my $id = lxq("query layerservice layer.id ? $i");
		lx("!!select.subItem {$id} add mesh;meshInst;camera;light;backdrop;groupLocator;locator;deform;locdeform 0 0");
		$deleteCount++;
	}
}

#delete all static meshes and instances
my $itemCount = lxq("query sceneservice item.n ? all");
for (my $i=0; $i<$itemCount; $i++){
	my $type = lxq("query sceneservice item.type ? $i");
	if (($type eq "triSurf") || ($type eq "meshInst")){
		my $id = lxq("query sceneservice item.id ? $i");
		lx("!!select.subItem {$id} add mesh;meshInst;camera;light;backdrop;groupLocator;locator;deform;locdeform 0 0");
		$deleteCount++;
	}
}

if ($deleteCount > 0){lx("!!delete");}

#prepare the polys for the first save
lx("!!select.subItem {$mainlayerID} set mesh;meshInst;camera;light;backdrop;groupLocator;locator;deform;locdeform 0 0");
my $refreshLayerID = lxq("query layerservice layer.id ? $mainlayer");
lx("!!unhide");
lx("!!select.drop polygon");
lx("!!poly.triple");

#apply the material and delete all non terrain uv maps
$mainlayerName = lxq("query layerservice layer.name ? $mainlayer");
my $vmapCount = lxq("query layerservice vmap.n ?");
for (my $i=0; $i<$vmapCount; $i++){
	if (lxq("query layerservice vmap.type ? $i") eq "texture"){
		my $name = lxq("query layerservice vmap.name ? $i");
		if ($name =~ /terrain/i){
			$bakeUVmapName = $name;
			lx("!!select.vertexMap {$name} txuv remove");
		}else{
			lx("!!select.vertexMap {$name} txuv add");
		}
	}
}
if ($bakeUVmapName eq ""){die("I couldn't find any UV maps that had any names with the word 'terrain' in them so I'm cancelling the script because I don't know which UV map to keep (or material name to apply to the polygons, because the script uses the found uv map name as the name to determine which material to apply to the polygons).");}


#this will now select all polys with the selection set called "nonUnique" and if it succeeds, it will cut them out and save them to a new layer in a moment.
lx("!!select.useSet {nonUnique} select");
if (lxq("select.count polygon ?") > 0){
	lxout("[->] : found a polygon selection set called 'nonUnique' so I'm going to export those to a new model and not apply the unique material to them. (This is for spires and pillars, btw)");
	our $uniquePolySave = 1;
	lx("select.cut");
}

#delete the non unique uv set(s) and save the unique geometry out.
lx("!!vertMap.delete txuv");

if (0){  #this is a special material application routine for the dead city model. it keeps the smoothing groups (supposedly)
	my $sceneFileName = lxq("query sceneservice scene.name ? current");
	my $itemCount = lxq("query sceneservice item.n ? all");
	my %smAngleTable;
	my %materialSafetyCheckTable;
	my $count = 0;

	for (my $i=0; $i<$itemCount; $i++){
		if (lxq("query sceneservice item.type ? $i") eq "mask"){
			my $id = lxq("query sceneservice item.id ? $i");
			my $ptag = lxq("query sceneservice channel.value ? ptag");
			my @children = lxq("query sceneservice item.children ? $i");
			my $smoothing = 0;

			foreach my $child (@children){
				if (lxq("query sceneservice item.type ? $child") eq "advancedMaterial"){
					lx("select.subItem {$child} set textureLayer;render;environment;light;camera;mediaClip;txtrLocator");
					$smoothing = int(lxq("item.channel advancedMaterial\$smAngle ?")+0.5);
				}
			}
			push(@{$smAngleTable{$smoothing}},$ptag);
		}
	}

	my $materialCount = lxq("query layerservice material.n ? visible");
	for (my $i=0; $i<$materialCount; $i++){
		my $name = lxq("query layerservice material.name ? $i");
		$materialSafetyCheckTable{$name} = 1;
	}

	foreach my $key (sort keys %smAngleTable){
		lxout("$key----------------");
		foreach my $material (@{$smAngleTable{$key}}){
			lxout("material = $material");
		}
	}

	foreach my $key (sort keys %smAngleTable){
		foreach my $material (@{$smAngleTable{$key}}){
			if ($materialSafetyCheckTable{$material} != 1){next;}
			my $newBakeUVMapName = lc($bakeUVmapName);
			my $letter = uc(substr($newBakeUVMapName,$count,1));
			if ($letter =~ /[\\\/_]/){ #TEMP : this is failing!
				$count++;
				$letter = uc(substr($newBakeUVMapName,$count,1));
			}
			substr($newBakeUVMapName, $count, 1) = $letter;

			lx("select.drop polygon");
			lx("!!select.polygon add material face {$material}");
			lx("!!poly.setMaterial {$newBakeUVMapName}");
			lx("item.channel advancedMaterial\$smAngle $key");
		}
		$count++;
	}
	lx("!!scene.saveAs [$sceneName] {$lwoType} [True]");
}else{
	lx("!!poly.setMaterial {$bakeUVmapName}");
	lx("!!item.channel advancedMaterial\$smAngle 180.0");
	lx("!!scene.saveAs [$sceneName] {$lwoType} [True]");
}



#export the models scene
if ($uniquePolySave == 1){
	lx("select.drop polygon");
	lx("delete");
	lx("select.paste");
	lx("select.all");
	lx("!!select.vertexMap {$bakeUVmapName} txuv add");
	lx("!!vertMap.delete txuv");

	$sceneName =~ s/\./_models\./;
	lx("scene.saveAs [$sceneName] {$lwoType} [True]");
}

#kill the script to undo everything
die("This is the only hack way to end the script");










#------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------
#POPUP SUB
#------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------
#USAGE : popup("What I wanna print");
sub popup #(MODO2 FIX)
{
	lx("dialog.setup yesNo");
	lx("dialog.msg {@_}");
	lx("dialog.open");
	my $confirm = lxq("dialog.result ?");
	if($confirm eq "no"){die;}
}
